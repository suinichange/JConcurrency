多线程
首先是考虑一个数据的安全性
于是我们会对代码进行加锁的处理(为了安全)
锁太多呢会导致效率的变低
于是我们需要把锁的粒度放细(为了性能)
放细就会导致死锁.
(synchronized的使用 对使用的数据对象加锁 范围为{}内的代码块内容)

死锁分析:
在任何地方都可以线程切换,甚至在一句语句中间
要尽力设想对自己最不利的情况

死锁条件,必须同时满足:
互斥等待(上锁)
占有且等待(拿着锁 在等待)
无法剥夺等待(等了就一直等)
循环等待(你等我 我等你)

死锁防止:
破除互斥等待 --> 去掉锁,无锁化  | 	修改上比较难,除非一开始就设计的无锁化,一般无法破除;
破除 Hold And Wait  -->一次性获取所有资源; |我们可以先hold 然后wait 一段时间,如果还拿不到锁就放弃原先hold的锁.过段时间再来获取.当然这也会等一些时间.
破除循环等待 --> 按顺序获取资源;
破除无法剥夺等待 --> 加入超时 | 这种是不得已的方法,会等时间长,而且会失败,用户体验不好;
(方法不唯一,最终看效果折中,每个方式都有优缺)