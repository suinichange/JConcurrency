## Java对象头？
　　在了解偏向锁、轻量锁、重量锁之前，我们需要先了解一个概念：Java对象头。Java对象头存储着对象锁的相关信息，以此标识锁的类型：无锁、偏向锁、轻量级锁、重量级锁。

## 偏向锁

### 为什么使用偏向锁？
　　大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

### 偏向锁怎么实现？
　　当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在**进入和退出同步块时不需要进行CAS操作来加锁和解锁**，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。(通过CAS将锁标志改为：偏向锁，并把对象头指向的线程的ID改为自己的ID；以后访问的时候只需要比较ID就行了。)

### 偏向锁的撤销

　　偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。

　　它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，重新偏向线程；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，如果仍有线程需要持有该偏向锁（说明存在竞争），偏向锁升级为轻量级锁。

### 偏向锁的优缺点和适用场景

　　优点：加锁和解锁不需要额外开销，效率快

　　缺点：如果线程间存在锁竞争，会带来额外的锁撤销的开销

　　适用场景：只有一个线程访问同步块的情况
  
## 轻量锁，重量锁

### 轻量锁加锁
　　线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用**CAS将对象头中的Mark Word替换为指向锁记录的指针**。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用**自旋**来获取锁。

### 轻量锁解锁，升级成重量锁
　　轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

　　自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量锁，就不会再恢复到轻量锁状态。当锁处于重量锁状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

### 轻量锁的优缺点和适用场景

　　优点：竞争线程不会阻塞，提高了线程的反应速度。

　　缺点：若同步块执行时间较长，线程会一直获得不到锁，一直自旋，浪费CPU资源。

　　适用场景：锁竞争不激烈且锁占用时间较短的情况下，追求响应时间。

### 重量锁的优缺点和适用场景

　　优点：在锁的竞争激烈的情况下提高了获得锁和释放锁的效率，防止CPU空自旋。

　　缺点：竞争线程会阻塞，响应时间慢。

　　适用场景：锁的竞争激烈或者持有锁时间较长的情况，追求吞吐量。
  
　　参考书籍：《Java 并发编程艺术》
