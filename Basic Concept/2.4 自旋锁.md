## 自旋锁

###为什么要引入自旋锁？
　　如前所述，在单CPU系统中，CPU在执行读一修改一写原语操作时，是具有原子性的，即在执行这些操作时不会被中断。保证原子性的基本方法是，在执行原语之前关中断，完成后再开中断。但是，在对称多处理机系统中，CPU在执行读一修改一写原语时，已不能再保证其操作的原子性。因为CPU所执行的读一修改一写原语操作通常都包含了若干条指令，因此需要执行多次总线操作。而在多处理机系统中，总线往往又是由多个处理机共享，它们是通过竞争来获取总线的。如果某CPU在执行原语的过程中由其它CPU争得了总线，就可能会导致该CPU与其它CPU对同一存储单元读一写操作的交又，造成混乱。

　　因此，在多处理机系统中，还必须引入对总线实现互斥的机制。于是，自旋锁机制也就应运而生，并已大量应用于对总线资源的竞争。当然，自旋锁机制并不局限于对总线资源的竞争

### 实现对总线互斥访问的方法

　　利用自旋锁实现对总线互斥访问的方法是：在总线上设置一个自旋锁，该锁最多只能被一个内核进程持有。当一个内核进程需要使用总线，对某个存储单元进行读写访问时，先请求自旋锁，以获得对总线的使用权。如果该锁被占用，那么这个进程就会一直进行“旋转”，循环测试锁的状态，直到自旋锁重新可用。如果锁未被占用，请求该锁的内核进程便能立刻得到它，并且继续执行，直到完成对指定存储单元的读写操作后，释放该锁。可见，自旋锁可以在任何时刻防止多个内核进程同时进入临界区，因此可有效地避免多处理机上并发运行的内核进程对总线资源的竞争。

### 自旋锁与信号量的主要差别

　　自旋锁与信号量的主要差别在于：自旋锁可避免调用进程阻塞。由于自旋锁使用者一般保持锁时间非常短，调用进程用“旋转”来取代进程切换。而我们知道进程切换需要花费一定开销，并且会使高速缓存失效，直接影响系统的性能，因此将自旋锁应用于对总线源的竞争，其效率远高于信号量机制，且在多处理器环境中非常方便。

　　显然，用自旋锁所保护的临界区一般都应比较短，否则，发出请求的多个CPU在锁被占用时，就会不断对锁进行循环测试，长时间忙等，浪费过多的CPU资源。

　　一般而言，如果对于被保护的共享资源仅在进程的上下文访问，或有共享设备，或调用进程所保护的临界区较大时，应使用信号量进行保护。但是如果被保护的共享资源需要计算机操作中断上下文访问，或调用进程所保护的临界区非常小，即对共享资源的访问时间非常短的情况下，就应使用自旋锁。

　　自旋锁保持期间是不可抢占的，而信号量和读写信号量保持期间是可以被抢占的。自旋锁只有在内核可抢占或SMP的情况下才真正需要，在单CPU且不可抢占的内核下，为防止中断处理中的并发操作，可简单采用关闭中断的方式，不需要自旋锁，此时自旋锁的所有操作都是空操作。

### 自旋锁的类型

　　使用自旋锁的基本形式为：

```java
　　pin_lock(&lock);
　　临界区代码；
　　in unlock(&lock):
```
　　常用的自旋锁有三种类型：普通自旋锁、读写自旋锁和大读者自旋锁。

　　（1）普通自旋锁：若是锁可用，则将自旋锁变量置为0，否则为1。该类自旋锁的使用不会影响当前处理机的中断状态，一般在临界区的代码在禁止中断情况下使用，或者不能被中断处理程序所执行。

　　（2）读写自旋锁：允许多个读者同时以只读的方式访问相同的共享数据结构，但是当一个写者正在更新这个数据结构时，不允许其它读者或写者访问。该类自旋锁较普通自旋锁允许更高的并发性，只要有一个读者拥有，写者就不能强占。每个读写自旋锁包括一个n位的读者计数和一个解锁标记。一般而言，在写者等待的情况下，新进的读者较写者更容易抢占该锁。

　　（3）大读者自旋锁：获取读锁时只需要对本地读锁进行加锁，开销很小；获取写锁时则必须锁住所有CPU上的读锁，代价较高。