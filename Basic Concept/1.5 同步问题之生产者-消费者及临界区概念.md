## 生产者－消费者问题

　　生产者－消费者（ producer－consumer）问题是一个著名的进程同步问题。它描述的是一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个具有n个缓冲区的级冲池，生产者进程将其所生产的产品放入一个缓冲区中：消费者进程可从一个缓冲区中取走产品去消费。尽管所有的生产者进程和消费者进程都是以异步方式运行的，但它们之间必须保持同步，既不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品。

　　同时我们可以使用一个整型共享变量counter记录缓冲池的产品数量。若生产者产出一个产品，那么count+1。消费者消费一个产品count-1。以此确定缓冲区的产品数量，而这两个操作在机器语言实现是常用以下形式表述：

```java
//生产者生产一个产品
register1=counter;//系统将内存中的counter值赋予寄存器1
register1++;//寄存器1自增
counter=register1；//将寄存器1的值赋回内存中的counter

//消费者消费一个产品
register2=counter;//系统将内存中的counter值赋予寄存器2
register2--;//寄存器2自减
counter=register2；//将寄存器2的值赋回内存中的counter
```

　　若当前counter值为1，生产者与消费者进程按照以上程序顺序执行，无论先后最终counter值应仍为1，结果美好。但并发时，进程是交替执行的，程序可能是以下这样执行的：
```java

register1=counter;//寄存器1值为1
register1++;//寄存器1值为2

register2=counter;//寄存器2值为1
register2--;//寄存器2值为0

counter=register1；//counter为2
counter=register2；//counter为0
```

　　明显可以看到由于进程执行顺序的不可控制（异步性）导致了结果的混乱。为了预防这种错误发生，我们需要对变量counter进行互斥访问控制。

## 临界区
　　由上述可知，不论是硬件临界资源还是软件临界资源，多个进程必须互斥地对它进
行访问。我们把在每个进程中访问临界资源的那段代码称为临界区。显然，若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。

　　为此，每个进程在进入临界区之前，应先对临界资源进行检査，看它是否正被访问。如果未被访问，进程便可进入临界区对该资源进行访问，并设置它正被访问的标志。如果正被访问，则本进程不能进入临界区。

　　因此，必须在临界区前面增加一段用于进行上述检查的代码，把这段代码称为进入区（ entry section）。相应地，在临界区后面也要加上一段称为退出区（ exit section）的代码，用于将临界区正被访问的标志恢复为未被访问的标志。这与Java中使用synchronized实现代码类似。
```java
synchronized (Lock){//进入区：临界资源检査，上锁
     代码块//临界区               
}//退出区，释放锁
```

## 同步机制应遵循的规则

- 空闲让进
- 忙则等待
- 有限等待：控制时间，避免陷入“死等”。
- 让权等待：进程若不能进入临界区时应释放CPU资源，以免陷入“忙等”。

